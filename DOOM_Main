<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOOM 3D - Stick Man Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #gameContainer {
            position: relative;
            border: 2px solid #333;
        }
        
        #gameCanvas {
            display: block;
            background: #000;
        }
        
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ff0000;
            font-size: 12px;
            text-shadow: 2px 2px 4px #000;
            background: rgba(0,0,0,0.7);
            padding: 5px;
            border-radius: 5px;
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
        }
        
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: #00ff00;
        }
        
        #crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }
        
        #crosshair::after {
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            transform: translateX(-50%);
        }
        
        .hud {
            position: absolute;
            bottom: 10px;
            color: #00ff00;
            font-size: 14px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            background: rgba(0,0,0,0.7);
            padding: 5px 10px;
            border-radius: 5px;
        }
        
        .health-bar {
            left: 20px;
            background: #333;
            width: 150px;
            height: 15px;
            border: 2px solid #666;
            padding: 0;
        }
        
        .health-fill {
            background: linear-gradient(90deg, #ff0000, #ff6600, #00ff00);
            height: 100%;
            transition: width 0.3s;
        }
        
        .armor-bar {
            left: 190px;
            background: #333;
            width: 100px;
            height: 15px;
            border: 2px solid #666;
            padding: 0;
        }
        
        .armor-fill {
            background: linear-gradient(90deg, #0066ff, #00ccff);
            height: 100%;
            transition: width 0.3s;
        }
        
        .weapon-info {
            right: 20px;
        }
        
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            text-align: center;
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            display: none;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="crosshair"></div>
        <div id="instructions">
            WASD - Ruch | Mysz - Obracanie<br>
            Klik/Przytrzymaj - Strzelanie<br>
            R - Przeładowanie | F - Full Auto<br>
            ESC - Zwolnij mysz
        </div>
        <div class="hud health-bar">
            <div class="health-fill" id="healthFill" style="width: 100%;"></div>
        </div>
        <div class="hud armor-bar">
            <div class="armor-fill" id="armorFill" style="width: 0%;"></div>
        </div>
        <div class="hud weapon-info" id="weaponInfo">
            PISTOL | AMMO: 15/45<br>
            SEMI-AUTO
        </div>
        <div class="game-over" id="gameOver">
            GAME OVER<br>
            <small>Odśwież stronę aby zagrać ponownie</small>
        </div>
    </div>

    <script>
        class DoomGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = this.canvas.width;
                this.height = this.canvas.height;
                
                // Player properties
                this.player = {
                    x: 1.5,
                    y: 1.5,
                    angle: 0,
                    speed: 0.06,
                    health: 100,
                    armor: 0,
                    alive: true
                // Debug: Draw a simple test wall if raycasting fails
                if (numRays === this.width / 2) {
                    // Test rendering - draw some walls manually
                    this.ctx.fillStyle = '#ff6600';
                    this.ctx.fillRect(100, 150, 50, 300);
                    this.ctx.fillRect(300, 100, 50, 400);
                    this.ctx.fillRect(500, 120, 50, 360);
                };
                
                // Weapon system
                this.weapons = {
                    pistol: {
                        name: 'PISTOL',
                        ammo: 15,
                        maxAmmo: 15,
                        totalAmmo: 45,
                        damage: 25,
                        fireRate: 15,
                        reloadTime: 60,
                        fullAuto: false
                    },
                    rifle: {
                        name: 'RIFLE',
                        ammo: 30,
                        maxAmmo: 30,
                        totalAmmo: 120,
                        damage: 35,
                        fireRate: 8,
                        reloadTime: 90,
                        fullAuto: true
                    }
                };
                
                this.currentWeapon = 'pistol';
                this.shooting = false;
                this.shootingCooldown = 0;
                this.reloading = false;
                this.reloadTime = 0;
                this.fullAutoMode = false;
                this.mousePressed = false;
                
                // Map with items (2 = ammo, 3 = armor, 4 = weapon)
                this.map = [
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                    [1,0,0,0,2,0,0,0,1,0,3,0,0,0,0,1],
                    [1,0,1,1,0,0,0,0,1,0,0,0,1,1,2,1],
                    [1,0,1,0,0,0,4,0,0,0,0,0,0,1,0,1],
                    [1,0,1,0,0,1,1,1,1,1,1,0,0,1,0,1],
                    [1,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                    [1,0,0,0,0,0,0,2,0,3,0,0,0,0,0,1],
                    [1,0,1,1,0,0,0,1,1,1,0,0,1,1,0,1],
                    [1,0,0,0,2,0,0,1,0,1,0,0,4,0,0,1],
                    [1,0,0,0,0,0,0,1,0,1,0,0,0,0,3,1],
                    [1,0,1,1,0,0,0,0,0,0,0,0,1,1,0,1],
                    [1,0,0,0,0,2,0,0,0,0,0,3,0,0,0,1],
                    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
                ];
                
                this.mapWidth = this.map[0].length;
                this.mapHeight = this.map.length;
                
                // Items on map
                this.items = [];
                this.generateItems();
                
                // Input handling
                this.keys = {};
                this.mouseLocked = false;
                
                // Enemies with AI
                this.enemies = [
                    {x: 3.5, y: 3.5, health: 75, alive: true, angle: 0, speed: 0.02, shootCooldown: 0, lastSeen: 0},
                    {x: 8.5, y: 5.5, health: 75, alive: true, angle: Math.PI, speed: 0.02, shootCooldown: 0, lastSeen: 0},
                    {x: 12.5, y: 8.5, health: 75, alive: true, angle: Math.PI/2, speed: 0.02, shootCooldown: 0, lastSeen: 0},
                    {x: 5.5, y: 10.5, health: 75, alive: true, angle: 0, speed: 0.02, shootCooldown: 0, lastSeen: 0}
                ];
                
                // Projectiles
                this.bullets = [];
                this.enemyBullets = [];
                
                // Effects
                this.muzzleFlash = 0;
                this.hitMarkers = [];
                
                this.initializeEvents();
                this.gameLoop();
            }
            
            generateItems() {
                for (let y = 0; y < this.mapHeight; y++) {
                    for (let x = 0; x < this.mapWidth; x++) {
                        if (this.map[y][x] === 2) { // Ammo
                            this.items.push({x: x + 0.5, y: y + 0.5, type: 'ammo', collected: false});
                        } else if (this.map[y][x] === 3) { // Armor
                            this.items.push({x: x + 0.5, y: y + 0.5, type: 'armor', collected: false});
                        } else if (this.map[y][x] === 4) { // Weapon
                            this.items.push({x: x + 0.5, y: y + 0.5, type: 'weapon', collected: false});
                        }
                    }
                }
                
                // Clear items from map
                for (let y = 0; y < this.mapHeight; y++) {
                    for (let x = 0; x < this.mapWidth; x++) {
                        if (this.map[y][x] > 1) this.map[y][x] = 0;
                    }
                }
            }
            
            initializeEvents() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code.toLowerCase()] = true;
                    
                    if (e.code === 'Escape') {
                        document.exitPointerLock();
                        this.mouseLocked = false;
                    }
                    
                    if (e.code === 'KeyR' && !this.reloading) {
                        this.reload();
                    }
                    
                    if (e.code === 'KeyF') {
                        this.fullAutoMode = !this.fullAutoMode;
                        this.updateWeaponInfo();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code.toLowerCase()] = false;
                });
                
                this.canvas.addEventListener('mousedown', (e) => {
                    if (!this.mouseLocked) {
                        this.canvas.requestPointerLock();
                    } else {
                        this.mousePressed = true;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mousePressed = false;
                });
                
                document.addEventListener('pointerlockchange', () => {
                    this.mouseLocked = document.pointerLockElement === this.canvas;
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (this.mouseLocked) {
                        this.player.angle += e.movementX * 0.002;
                    }
                });
            }
            
            reload() {
                const weapon = this.weapons[this.currentWeapon];
                if (weapon.ammo < weapon.maxAmmo && weapon.totalAmmo > 0) {
                    this.reloading = true;
                    this.reloadTime = weapon.reloadTime;
                }
            }
            
            shoot() {
                if (this.reloading || this.shootingCooldown > 0) return;
                
                const weapon = this.weapons[this.currentWeapon];
                if (weapon.ammo <= 0) {
                    this.reload();
                    return;
                }
                
                weapon.ammo--;
                this.shootingCooldown = weapon.fireRate;
                this.muzzleFlash = 5;
                
                // Create bullet
                this.bullets.push({
                    x: this.player.x,
                    y: this.player.y,
                    angle: this.player.angle,
                    speed: 0.3,
                    damage: weapon.damage,
                    life: 100
                });
                
                this.updateWeaponInfo();
            }
            
            updateWeaponInfo() {
                const weapon = this.weapons[this.currentWeapon];
                const mode = this.fullAutoMode && weapon.fullAuto ? 'FULL-AUTO' : 'SEMI-AUTO';
                document.getElementById('weaponInfo').innerHTML = 
                    `${weapon.name} | AMMO: ${weapon.ammo}/${weapon.totalAmmo}<br>${mode}`;
            }
            
            update() {
                if (!this.player.alive) return;
                
                // Player movement
                const moveSpeed = this.player.speed;
                let newX = this.player.x;
                let newY = this.player.y;
                
                if (this.keys['keyw']) {
                    newX += Math.cos(this.player.angle) * moveSpeed;
                    newY += Math.sin(this.player.angle) * moveSpeed;
                }
                if (this.keys['keys']) {
                    newX -= Math.cos(this.player.angle) * moveSpeed;
                    newY -= Math.sin(this.player.angle) * moveSpeed;
                }
                if (this.keys['keya']) {
                    newX += Math.cos(this.player.angle - Math.PI/2) * moveSpeed;
                    newY += Math.sin(this.player.angle - Math.PI/2) * moveSpeed;
                }
                if (this.keys['keyd']) {
                    newX += Math.cos(this.player.angle + Math.PI/2) * moveSpeed;
                    newY += Math.sin(this.player.angle + Math.PI/2) * moveSpeed;
                }
                
                // Collision detection
                if (this.map[Math.floor(newY)][Math.floor(newX)] === 0) {
                    this.player.x = newX;
                    this.player.y = newY;
                }
                
                // Shooting
                const weapon = this.weapons[this.currentWeapon];
                if (this.mousePressed && (this.fullAutoMode && weapon.fullAuto || !this.fullAutoMode)) {
                    this.shoot();
                } else if (this.mousePressed && !this.fullAutoMode) {
                    this.shoot();
                    this.mousePressed = false;
                }
                
                // Update shooting cooldown
                if (this.shootingCooldown > 0) this.shootingCooldown--;
                
                // Update reloading
                if (this.reloading) {
                    this.reloadTime--;
                    if (this.reloadTime <= 0) {
                        const weapon = this.weapons[this.currentWeapon];
                        const needed = weapon.maxAmmo - weapon.ammo;
                        const available = weapon.totalAmmo;
                        const reload = Math.min(needed, available);
                        
                        weapon.ammo += reload;
                        weapon.totalAmmo -= reload;
                        this.reloading = false;
                        this.updateWeaponInfo();
                    }
                }
                
                // Update muzzle flash
                if (this.muzzleFlash > 0) this.muzzleFlash--;
                
                // Update bullets
                this.updateBullets();
                
                // Update enemies
                this.updateEnemies();
                
                // Check item collection
                this.checkItemCollection();
                
                // Update hit markers
                this.hitMarkers = this.hitMarkers.filter(marker => marker.life-- > 0);
            }
            
            updateBullets() {
                // Player bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    bullet.life--;
                    
                    // Check wall collision
                    if (this.map[Math.floor(bullet.y)][Math.floor(bullet.x)] === 1 || bullet.life <= 0) {
                        this.bullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check enemy collision
                    for (let enemy of this.enemies) {
                        if (enemy.alive) {
                            const dx = enemy.x - bullet.x;
                            const dy = enemy.y - bullet.y;
                            if (Math.sqrt(dx * dx + dy * dy) < 0.3) {
                                enemy.health -= bullet.damage;
                                this.hitMarkers.push({x: enemy.x, y: enemy.y, life: 30});
                                
                                if (enemy.health <= 0) {
                                    enemy.alive = false;
                                }
                                
                                this.bullets.splice(i, 1);
                                break;
                            }
                        }
                    }
                }
                
                // Enemy bullets
                for (let i = this.enemyBullets.length - 1; i >= 0; i--) {
                    const bullet = this.enemyBullets[i];
                    bullet.x += Math.cos(bullet.angle) * bullet.speed;
                    bullet.y += Math.sin(bullet.angle) * bullet.speed;
                    bullet.life--;
                    
                    // Check wall collision
                    if (this.map[Math.floor(bullet.y)][Math.floor(bullet.x)] === 1 || bullet.life <= 0) {
                        this.enemyBullets.splice(i, 1);
                        continue;
                    }
                    
                    // Check player collision
                    const dx = this.player.x - bullet.x;
                    const dy = this.player.y - bullet.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 0.3) {
                        let damage = 15;
                        if (this.player.armor > 0) {
                            const absorbed = Math.min(damage * 0.6, this.player.armor);
                            this.player.armor -= absorbed;
                            damage -= absorbed;
                        }
                        
                        this.player.health -= damage;
                        if (this.player.health <= 0) {
                            this.player.alive = false;
                            document.getElementById('gameOver').style.display = 'block';
                        }
                        
                        this.updateHealthBar();
                        this.enemyBullets.splice(i, 1);
                    }
                }
            }
            
            updateEnemies() {
                for (let enemy of this.enemies) {
                    if (!enemy.alive) continue;
                    
                    const dx = this.player.x - enemy.x;
                    const dy = this.player.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx);
                    
                    // Simple AI: move towards player if close, shoot if in line of sight
                    if (distance < 6) {
                        enemy.lastSeen = 60; // Remember player position
                        
                        // Move towards player
                        const newX = enemy.x + Math.cos(angle) * enemy.speed;
                        const newY = enemy.y + Math.sin(angle) * enemy.speed;
                        
                        if (this.map[Math.floor(newY)][Math.floor(newX)] === 0) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                        
                        enemy.angle = angle;
                        
                        // Shoot at player
                        if (enemy.shootCooldown <= 0 && distance < 5) {
                            this.enemyBullets.push({
                                x: enemy.x,
                                y: enemy.y,
                                angle: angle + (Math.random() - 0.5) * 0.2, // Some inaccuracy
                                speed: 0.15,
                                life: 100
                            });
                            enemy.shootCooldown = 40 + Math.random() * 40;
                        }
                    } else if (enemy.lastSeen > 0) {
                        // Random movement when not seeing player
                        enemy.lastSeen--;
                        enemy.angle += (Math.random() - 0.5) * 0.1;
                        
                        const newX = enemy.x + Math.cos(enemy.angle) * enemy.speed * 0.5;
                        const newY = enemy.y + Math.sin(enemy.angle) * enemy.speed * 0.5;
                        
                        if (this.map[Math.floor(newY)][Math.floor(newX)] === 0) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    }
                    
                    if (enemy.shootCooldown > 0) enemy.shootCooldown--;
                }
            }
            
            checkItemCollection() {
                for (let item of this.items) {
                    if (item.collected) continue;
                    
                    const dx = this.player.x - item.x;
                    const dy = this.player.y - item.y;
                    if (Math.sqrt(dx * dx + dy * dy) < 0.4) {
                        item.collected = true;
                        
                        switch (item.type) {
                            case 'ammo':
                                this.weapons[this.currentWeapon].totalAmmo += 30;
                                break;
                            case 'armor':
                                this.player.armor = Math.min(100, this.player.armor + 25);
                                break;
                            case 'weapon':
                                if (this.currentWeapon === 'pistol') {
                                    this.currentWeapon = 'rifle';
                                    this.updateWeaponInfo();
                                }
                                break;
                        }
                        
                        this.updateHealthBar();
                    }
                }
            }
            
            updateHealthBar() {
                document.getElementById('healthFill').style.width = `${this.player.health}%`;
                document.getElementById('armorFill').style.width = `${this.player.armor}%`;
            }
            
            castRay(angle) {
                const rayDirX = Math.cos(angle);
                const rayDirY = Math.sin(angle);
                
                let x = this.player.x;
                let y = this.player.y;
                
                const stepSize = 0.01; // Smaller steps for better accuracy
                let steps = 0;
                const maxSteps = 1000;
                
                while (steps < maxSteps) {
                    x += rayDirX * stepSize;
                    y += rayDirY * stepSize;
                    steps++;
                    
                    const mapX = Math.floor(x);
                    const mapY = Math.floor(y);
                    
                    // Check bounds
                    if (mapX < 0 || mapX >= this.mapWidth || mapY < 0 || mapY >= this.mapHeight) {
                        break;
                    }
                    
                    // Check wall hit
                    if (this.map[mapY][mapX] === 1) {
                        const distance = Math.sqrt((x - this.player.x) ** 2 + (y - this.player.y) ** 2);
                        return distance;
                    }
                }
                
                // Return max distance if no wall hit
                return 20;
            }
            
            drawStickFigure(ctx, x, y, size, color = '#ff0000') {
                if (size > 200) size = 200; // Limit max size
                if (size < 10) return; // Don't draw if too small
                
                ctx.save();
                ctx.translate(x, y);
                ctx.strokeStyle = color;
                ctx.lineWidth = Math.max(2, size / 15);
                
                // Head
                ctx.beginPath();
                ctx.arc(0, -size * 0.35, size * 0.12, 0, Math.PI * 2);
                ctx.stroke();
                
                // Body
                ctx.beginPath();
                ctx.moveTo(0, -size * 0.23);
                ctx.lineTo(0, size * 0.15);
                ctx.stroke();
                
                // Arms
                ctx.beginPath();
                ctx.moveTo(-size * 0.15, -size * 0.05);
                ctx.lineTo(size * 0.15, -size * 0.05);
                ctx.stroke();
                
                // Legs
                ctx.beginPath();
                ctx.moveTo(0, size * 0.15);
                ctx.lineTo(-size * 0.1, size * 0.3);
                ctx.moveTo(0, size * 0.15);
                ctx.lineTo(size * 0.1, size * 0.3);
                ctx.stroke();
                
                ctx.restore();
            }
            
            render() {
                // Clear canvas
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw sky
                this.ctx.fillStyle = '#16213e';
                this.ctx.fillRect(0, 0, this.width, this.height / 2);
                
                // Draw floor
                this.ctx.fillStyle = '#444444';
                this.ctx.fillRect(0, this.height / 2, this.width, this.height / 2);
                
                const fov = Math.PI / 3;
                const halfFov = fov / 2;
                const numRays = this.width / 2; // Reduce rays for better performance
                
                // Cast rays and draw walls
                for (let i = 0; i < numRays; i++) {
                    const rayAngle = this.player.angle - halfFov + (i / numRays) * fov;
                    const distance = this.castRay(rayAngle);
                    
                    if (distance > 0) {
                        const correctedDistance = distance * Math.cos(rayAngle - this.player.angle);
                        const wallHeight = Math.min(this.height, (this.height / correctedDistance) * 0.8);
                        const wallTop = (this.height - wallHeight) / 2;
                        
                        // Better wall shading
                        const shade = Math.max(30, Math.min(255, 255 - distance * 20));
                        this.ctx.fillStyle = `rgb(${shade}, ${Math.floor(shade * 0.7)}, ${Math.floor(shade * 0.3)})`;
                        
                        // Draw wider strips for better visibility
                        const stripWidth = Math.ceil(this.width / numRays);
                        this.ctx.fillRect(i * stripWidth, wallTop, stripWidth, wallHeight);
                    }
                }
                
                // Draw items
                for (let item of this.items) {
                    if (item.collected) continue;
                    
                    const dx = item.x - this.player.x;
                    const dy = item.y - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) - this.player.angle;
                    
                    if (Math.abs(angle) < Math.PI / 2 && distance < 10) {
                        const screenX = (this.width / 2) + (Math.tan(angle) * this.width);
                        const itemSize = Math.max(8, 40 / distance);
                        
                        if (screenX >= 0 && screenX < this.width) {
                            let color = '#00ff00';
                            if (item.type === 'armor') color = '#0088ff';
                            else if (item.type === 'weapon') color = '#ffff00';
                            
                            this.ctx.fillStyle = color;
                            this.ctx.fillRect(screenX - itemSize/2, this.height/2 - itemSize/2, itemSize, itemSize);
                        }
                    }
                }
                
                // Draw enemies
                for (let enemy of this.enemies) {
                    if (!enemy.alive) continue;
                    
                    const dx = enemy.x - this.player.x;
                    const dy = enemy.y - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) - this.player.angle;
                    
                    if (Math.abs(angle) < Math.PI / 2 && distance < 10) {
                        const screenX = (this.width / 2) + (Math.tan(angle) * this.width);
                        const enemySize = Math.max(15, 80 / distance);
                        const enemyY = this.height/2;
                        
                        if (screenX >= -enemySize && screenX < this.width + enemySize) {
                            this.drawStickFigure(this.ctx, screenX, enemyY, enemySize, '#ff4444');
                        }
                    }
                }
                
                // Draw bullets
                [...this.bullets, ...this.enemyBullets].forEach(bullet => {
                    const dx = bullet.x - this.player.x;
                    const dy = bullet.y - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) - this.player.angle;

                    if (Math.abs(angle) < Math.PI / 2 && distance < 8) {
                        const screenX = (this.width / 2) + (Math.tan(angle) * this.width);
                        const bulletSize = Math.max(3, 8 / distance);

                        if (screenX >= 0 && screenX < this.width) {
                            this.ctx.fillStyle = '#ffff00';
                            this.ctx.beginPath();
                            this.ctx.arc(screenX, this.height/2, bulletSize, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                });

                // Draw hit markers
                this.hitMarkers.forEach(marker => {
                    const dx = marker.x - this.player.x;
                    const dy = marker.y - this.player.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) - this.player.angle;

                    if (Math.abs(angle) < Math.PI / 2 && distance < 10) {
                        const screenX = (this.width / 2) + (Math.tan(angle) * this.width);
                        const size = Math.max(5, 20 / distance);

                        if (screenX >= 0 && screenX < this.width) {
                            this.ctx.strokeStyle = '#ff0000';
                            this.ctx.beginPath();
                            this.ctx.moveTo(screenX - size, this.height/2 - size);
                            this.ctx.lineTo(screenX + size, this.height/2 + size);
                            this.ctx.moveTo(screenX - size, this.height/2 + size);
                            this.ctx.lineTo(screenX + size, this.height/2 - size);
                            this.ctx.stroke();
                        }
                    }
                });

                // Muzzle flash
                if (this.muzzleFlash > 0) {
                    this.ctx.fillStyle = 'rgba(255,255,0,0.7)';
                    this.ctx.beginPath();
                    this.ctx.arc(this.width/2, this.height/2, 30, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }

        window.addEventListener('load', () => {
            new DoomGame();
        });
    </script>
</body>
</html>
